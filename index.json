[{"content":"v2ray支持动态端口（dynamicPort），但这是协议的一种，无法与ws+tls共存，今天看到别人分享的用iptables去实现动态端口觉得思路很好 于是记录一下\n比如当前的v2ray端口是88\n那么使用iptables去开一个端口范围转发到88\niptables -t nat -A PREROUTING -p tcp --dport 40000:60000 -j REDIRECT --to-ports 88 上面的例子是将端口4000-6000的范围全部转发到88\n可以将json格式的配置文件放置在国内环境下，使用PHP去监控并自动修改\n\u0026lt;?php // 读取 us.json 文件 $json = file_get_contents(\u0026#39;us.json\u0026#39;); $data = json_decode($json, true); // 获取 address 和 port $address = $data[\u0026#39;outbounds\u0026#39;][0][\u0026#39;settings\u0026#39;][\u0026#39;vnext\u0026#39;][0][\u0026#39;address\u0026#39;]; $port = $data[\u0026#39;outbounds\u0026#39;][0][\u0026#39;settings\u0026#39;][\u0026#39;vnext\u0026#39;][0][\u0026#39;port\u0026#39;]; // 判断 TCP 连通性 function test_tcp_connection($ip, $port) { $timeout = 3; $socket = @fsockopen($ip, $port, $errno, $errstr, $timeout); if (!$socket) { return false; // connection failed } fclose($socket); return true; // connection successful } if (!test_tcp_connection($address,$port) \u0026amp;\u0026amp; $port \u0026gt;= 40000 \u0026amp;\u0026amp; $port \u0026lt;= 60000) { // 如果不能连接且端口在 40000-60000 范围内，则循环判断 $port++; while ($port \u0026lt;= 60000) { if (test_tcp_connection($address,$port)) { break; } $port++; } } elseif (!test_tcp_connection($address,$port) \u0026amp;\u0026amp; $port \u0026lt; 40000) { // 如果不能连接且端口小于 40000，则从 40000 开始 $port = 40000; while ($port \u0026lt;= 60000) { if (test_tcp_connection($address,$port)) { break; } $port++; } } if (test_tcp_connection($address,$port)) { echo \u0026#34;TCP 连通，端口号为：\u0026#34; . $port . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; // 如果原来的端口已经连通，则不更改 if ($port === $data[\u0026#39;outbounds\u0026#39;][0][\u0026#39;settings\u0026#39;][\u0026#39;vnext\u0026#39;][0][\u0026#39;port\u0026#39;]) { echo \u0026#34;原来的端口已经连通，不需要更改。\u0026#34;; } else { // 更新 us.json 文件中的 port 字段 $data[\u0026#39;outbounds\u0026#39;][0][\u0026#39;settings\u0026#39;][\u0026#39;vnext\u0026#39;][0][\u0026#39;port\u0026#39;] = $port; $updatedJson = json_encode($data, JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT); file_put_contents(\u0026#39;us.json\u0026#39;, $updatedJson); echo \u0026#34;端口已经更改为：\u0026#34; . $port; } } else { echo \u0026#34;TCP 连通失败。\u0026#34;; } ?\u0026gt; 启发来自：https://elmagnifico.tech/2023/02/22/V2ray-Dynamic-Port/\n","permalink":"https://csznet.github.io/posts/exp/v2ray-iptables/","summary":"\u003cp\u003ev2ray支持动态端口（dynamicPort），但这是协议的一种，无法与ws+tls共存，今天看到别人分享的用iptables去实现动态端口觉得思路很好\n于是记录一下\u003c/p\u003e","title":"v2ray使用iptables实现动态端口"},{"content":"ChatGPT官网的免费对话虽说免费，但是问题很多，比如一段时间不交互就要重新进入\n再比如稳定性差、经常需要CF验证，于是就自己使用API对接了一个\n一开始是直接使用的ChatGPT-Demo\n后来key额度被用完（120刀账户，用完5刀账户就被封了）\n觉得ChatGPT-Demo没有做防刷处理有点不安全（hash加密密钥根本就没调用上，超时验证也是无效的）\n就自己用Golang写了个简单的会员系统进行对接，做了游客提问周期限制\n虽然说是基于别人的项目进行二次开发，但也在开发的过程中熟悉了astro框架，对nodejs方面的认知得到提高\n写的会员系统也是比之前写的Golang代码质量要高得多，可以保留初版供后续开发\n","permalink":"https://csznet.github.io/project/chat-csznet/","summary":"\u003cp\u003eChatGPT官网的免费对话虽说免费，但是问题很多，比如一段时间不交互就要重新进入\u003cbr\u003e\n再比如稳定性差、经常需要CF验证，于是就自己使用API对接了一个\u003c/p\u003e","title":"对接ChatGPT使用3.5模型连续对话"},{"content":"尝试使用Caddy代替Nginx服务时，发现光使用SSH，不使用SCP、SFTP工具时，管理文件很是麻烦，也不想去装宝塔，索性就自己写了个简陋的在线文件管理器\n预览 介绍 使用Golang作为开发语言，并在Github开源 传送门\n目前实现了的功能：\n后台远程下载 上传文件\u0026amp;拖放上传 删除文件\u0026amp;文件夹 新建文件\u0026amp;文件夹 解压ZIP、gz压缩包 在线编辑文件 安装 环境支持 Linux支持 MacOS支持 不支持Windows（Windows再用这个就显得有点鸡肋了，虽然说支持MacOS也有点鸡肋\n脚本安装 bash \u0026lt;(curl -s https://raw.githubusercontent.com/csznet/goFile/main/goFile.sh) 手动安装 Releases 可以前往Github下载编译好了的Releases 传送门\n自己编译 也可以选择下载源码自己编译 传送门\n使用 如果是使用脚本安装，则在需要管理的目录运行goFile即可打开goFile服务管理当前目录下的文件\u0026amp;目录\n如果是下载二进制文件使用，则需要把二进制文件放置在需要管理的目录下或者带上path参数\n参数 支持自定义管理目录和运行的WEB端口\n-path 默认管理目录为调用服务的目录\n-port 默认端口为8089\nex：\n./goFile -path /root -port 80 表示在/root目录使用80端口运行goFile服务\n","permalink":"https://csznet.github.io/project/go-file/","summary":"\u003cp\u003e尝试使用Caddy代替Nginx服务时，发现光使用SSH，不使用SCP、SFTP工具时，管理文件很是麻烦，也不想去装宝塔，索性就自己写了个简陋的在线文件管理器\u003c/p\u003e","title":"go File - 简陋的在线文件管理器"},{"content":"此页面待填充\n","permalink":"https://csznet.github.io/about/","summary":"about","title":"关于"}]